// kernel: a function in computeShader
#pragma kernel ExternalGravity // 0
#pragma kernel UpdatePositions // 1
#pragma kernel calcDensity // 2
#pragma kernel calcPressureForce // 3
#pragma kernel calcViscosityForce // 4
#pragma kernel SpatialQueryKernel // 5


#include "./SmoothingKernel.hlsl"

struct Particle
{
    float3 position;
    float3 velocity;
    float3 currentForce;
    float density;
    float pressure;
};

struct Entry
{
    uint pointIndex;
    uint cellKey;
};

RWStructuredBuffer<Particle> _ParticleBuffer;
const uint numParticles;

StructuredBuffer<Entry> _SpatialLookup;
StructuredBuffer<uint> _StartIndices;
RWStructuredBuffer<float2> _Result;

const uint _NumPoints;
const uint _SpatialLookupLength;

float _DeltaTime;
const float3 _Gravity;

const float halfBoxWidth;
const float4x4 localToWorld;
const float4x4 worldToLocal;

static const uint NumThreads = 64; 
const float mass = 1.0;
const float radius = 1.0; //to be set
const float targetDensity = 1000.0; // to be set
const float pressureMultiplier = 1; // to be set
const float ngbPressureMultiplier = 1; // to be set
const float viscosityStrength = 0.1; // to be set

static const int3 inRadCellOffset[27] = {
    int3(-1, -1, -1), int3(0, -1, -1), int3(1, -1, -1),
    int3(-1, 0, -1), int3(0, 0, -1), int3(1, 0, -1),
    int3(-1, 1, -1), int3(0, 1, -1), int3(1, 1, -1),
    int3(-1, -1, 0), int3(0, -1, 0), int3(1, -1, 0),
    int3(-1, 0, 0), int3(0, 0, 0), int3(1, 0, 0),
    int3(-1, 1, 0), int3(0, 1, 0), int3(1, 1, 0),
    int3(-1, -1, 1), int3(0, -1, 1), int3(1, -1, 1),
    int3(-1, 0, 1), int3(0, 0, 1), int3(1, 0, 1),
    int3(-1, 1, 1), int3(0, 1, 1), int3(1, 1, 1)
};


// helper function start
int3 PositionToCellCoord(float3 pos, float radius)
{
    int cellX = (int)(pos.x / radius);
    int cellY = (int)(pos.y / radius);
    int cellZ = (int)(pos.z / radius);
    return int3(cellX, cellY, cellZ);
}

uint HashCell(int cellX, int cellY, int cellZ)
{
    uint a = (uint)(cellX) * 73856093;
    uint b = (uint)(cellY) * 19349663;
    uint c = (uint)(cellZ) * 83492791;
    return a ^ b ^ c;
}

uint GetKeyFromHash(uint hash)
{
    return hash % _SpatialLookupLength;
}
// helper function end



[numthreads(NumThreads, 1, 1)]
void ExternalGravity(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles) return;
    Particle particle = _ParticleBuffer[id.x];
    particle.velocity += _Gravity * _DeltaTime;
    _ParticleBuffer[id.x] = particle;
}

void HandleBoundingBoxCollision(uint3 id : SV_DispatchThreadID) {

    Particle particle = _ParticleBuffer[id.x];
    
    // Local scale
    float3 localPos = mul(worldToLocal, float4(particle.position, 1.0)).xyz;
    float3 localVelocity = mul(worldToLocal, float4(particle.velocity, 0.0)).xyz;

    // Check for collision with the bounding box
    if (localPos.x < -halfBoxWidth || localPos.x > halfBoxWidth) {
        localVelocity.x = -localVelocity.x * 0.5; // Reflect and dampen
        localPos.x = clamp(localPos.x, -halfBoxWidth, halfBoxWidth);
    }

    if (localPos.y < -halfBoxWidth || localPos.y > halfBoxWidth) {
        localVelocity.y = -localVelocity.y * 0.5; // Reflect and dampen
        localPos.y = clamp(localPos.y, -halfBoxWidth, halfBoxWidth);
    }

    if (localPos.z < -halfBoxWidth || localPos.z > halfBoxWidth) {
        localVelocity.z = -localVelocity.z * 0.5; // Reflect and dampen
        localPos.z = clamp(localPos.z, -halfBoxWidth, halfBoxWidth);
    }

    // Transform back to world space
    particle.position = mul(localToWorld, float4(localPos, 1.0)).xyz;
    particle.velocity = mul(localToWorld, float4(localVelocity, 0.0)).xyz;
    _ParticleBuffer[id.x] = particle;
}

[numthreads(NumThreads, 1, 1)]
void calcDensity(uint3 id : SV_DispatchThreadID) {
    // based on formula 3
    if (id.x >= _NumPoints) return;
    Particle me = _ParticleBuffer[id.x];
    float3 samplePoint = me.position;

    float density = 0.0;

    int3 owncell = PositionToCellCoord(samplePoint, radius);

    for (int radCell=0; radCell < 27; radCell++) {
        int3 ngbCell = owncell + inRadCellOffset[radCell];

        uint key = GetKeyFromHash(HashCell(ngbCell.x, ngbCell.y, ngbCell.z));
        uint start = _StartIndices[key];
        uint end = (key + 1 < _SpatialLookupLength) ? _StartIndices[key + 1] : _NumPoints;

        for (uint i = start; i < end; i++) {
            uint ngbInd = _SpatialLookup[i].pointIndex;
            if (ngbInd == id.x) continue; // Skip self
            Particle ngb = _ParticleBuffer[ngbInd];
            float3 diff = samplePoint - ngb.position;
            float d = length(diff);
            if (d > radius) continue;
            density += SmoothingKernelPoly6(d, radius) * mass;
        }
    }
    me.density = density;
    _ParticleBuffer[id.x] = me;
}



[numthreads(NumThreads, 1, 1)]
void calcPressureForce(uint3 id : SV_DispatchThreadID) {
    // based on formula 10
    if (id.x >= numParticles) return;
    Particle particle = _ParticleBuffer[id.x];
    
    float3 pressureForce = 0.0;
    for (uint i = 0; i < numParticles; i++) {
        if (i == id.x) continue; // Skip self
        Particle otherParticle = _ParticleBuffer[i];
        float3 diff = particle.position - otherParticle.position;
        float distance = length(diff);

        float ngbDensity = max(otherParticle.density, 0.001f);
        float selfPressure = (particle.density - targetDensity) * pressureMultiplier; 
        float otherPressure = ngbDensity * ngbPressureMultiplier; 
        float meanPressure = (selfPressure + otherPressure) / (2.0 * ngbDensity);

        float3 dir = distance > 0 ? normalize(diff) : float3(0, 1, 0);

        pressureForce += dir * mass * meanPressure * smoothingKernelDerivative(distance, radius); // eq. 10
    }

    float3 acceleration = pressureForce / max(particle.density, 0.001f); // eq. 8
    particle.velocity += acceleration * _DeltaTime;
    _ParticleBuffer[id.x] = particle;
}

[numthreads(NumThreads, 1, 1)]
void calcViscosityForce(uint3 id : SV_DispatchThreadID) {
    // based on formula 14
    if (id.x >= numParticles) return;
    Particle particle = _ParticleBuffer[id.x];
    
    float3 viscosityForce = 0;
    float3 velocity = particle.velocity;

    for (uint i = 0; i < numParticles; i++) {
        if (i == id.x) continue; // Skip self
        Particle otherParticle = _ParticleBuffer[i];
        float3 diff = particle.position - otherParticle.position;
        float distance = length(diff);

        if (distance > radius) continue;

        viscosityForce += (otherParticle.velocity - velocity) * SmoothingKernelPoly6(distance, radius);
    }
    particle.velocity += viscosityForce * _DeltaTime * viscosityStrength; //viscosityStrength = mu
    _ParticleBuffer[id.x] = particle;
}


[numthreads(NumThreads, 1, 1)]
void UpdatePositions(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;
    Particle particle = _ParticleBuffer[id.x];
    particle.position += particle.velocity * _DeltaTime;
    _ParticleBuffer[id.x] = particle;
    HandleBoundingBoxCollision(id);
}


"""
[numthreads(NumThreads, 1, 1)]
void SpatialQueryKernel(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _NumPoints) return;

    Particle me = _ParticleBuffer[id.x];
    float3 samplePoint = me.position;

    float sqrRadius = radius * radius;

    int2 centre = PositionToCellCoord(samplePoint, radius);

    float3 force = float3(0, 0, 0);

    for (int ox = -1; ox <= 1; ox++)
    for (int oy = -1; oy <= 1; oy++)
    for (int oz = -1; oz <= 1; oz++)
    {
        uint key = GetKeyFromHash(HashCell(centre.x + ox, centre.y + oy, centre.z + oz));
        uint start = _StartIndices[key];
        uint end = (key + 1 < _SpatialLookupLength) ? _StartIndices[key + 1] : _NumPoints;

        for (uint i = start; i < end; i++)
        {
            uint neighborIdx = _SpatialLookup[i].pointIndex;
            Particle neighbor = _ParticleBuffer[neighborIdx];
            float3 neighborPos = neighbor.position;

            float d2 = distance(neighborPos, samplePoint);
            if (d2 < sqrRadius)
            {
                // 範例行為：累積方向向量 (idk why chatGPT do this)
                force += normalize(neighborPos - samplePoint);
            }
        }
    }
    me.currentForce = force;
    _ParticleBuffer[id.x] = me;
}
"""