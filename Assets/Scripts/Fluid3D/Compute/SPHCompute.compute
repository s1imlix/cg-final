// kernel: a function in computeShader
#pragma kernel CSMain // 0
#pragma kernel ExternalGravity // 1
#pragma kernel HandleBoundingBoxCollision // 2
#pragma kernel SpatialQueryKernel // 3

struct Particle
{
    float3 position;
    float3 velocity;
    float3 currentForce;
    float density;
    float pressure;
};

RWStructuredBuffer<Particle> _ParticleBuffer;
const uint numParticles;

struct Entry
{
    uint pointIndex;
    uint cellKey;
};

StructuredBuffer<Entry> _SpatialLookup;
StructuredBuffer<uint> _StartIndices;
StructuredBuffer<float3> _Positions;
RWStructuredBuffer<float3> _Result;

const float _Radius;
const uint _NumPoints;
const uint _SpatialLookupLength;


float _DeltaTime;
const float3 _Gravity;

const float4x4 localToWorld;
const float4x4 worldToLocal;

static const uint NumThreads = 64; 

[numthreads(NumThreads,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Particle particle = _ParticleBuffer[id.x];
    particle.velocity += _Gravity * _DeltaTime;
    particle.position += particle.velocity * _DeltaTime;
    
    // add some bouncing shit
    
    if (particle.position.y < 0) {
        particle.position.y = 0;
        particle.velocity.y = -particle.velocity.y * 0.5; 
    }
    
    _ParticleBuffer[id.x] = particle;
}

[numthreads(NumThreads, 1, 1)]
void ExternalGravity(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles) return;
    Particle particle = _ParticleBuffer[id.x];
    particle.velocity += _Gravity * _DeltaTime;
    _ParticleBuffer[id.x] = particle;
}

[numthreads(NumThreads, 1, 1)]
void HandleBoundingBoxCollision(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numParticles) return;
    Particle particle = _ParticleBuffer[id.x];
    
    float3 localPos = mul(worldToLocal, float4(particle.position, 1.0)).xyz;
    float3 localVelocity = mul(worldToLocal, float4(particle.velocity, 0.0)).xyz;
}

// helper function start
int3 PositionToCellCoord(float3 point, float radius)
{
    int cellX = (int)(point.x / radius);
    int cellY = (int)(point.y / radius);
    int cellZ = (int)(point.z / radius);
    return int3(cellX, cellY, cellZ);
}

uint HashCell(int cellX, int cellY, int cellZ)
{
    uint a = (uint)(cellX) * 73856093;
    uint b = (uint)(cellY) * 19349663;
    uint c = (uint)(cellZ) * 83492791;
    return a ^ b ^ c;
}

uint GetKeyFromHash(uint hash)
{
    return hash % _SpatialLookupLength;
}
// helper function end
[numthreads(NumThreads, 1, 1)]
void SpatialQueryKernel(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _NumPoints) return;

    float3 samplePoint = _Positions[id.x];
    float sqrRadius = _Radius * _Radius;

    int2 centre = PositionToCellCoord(samplePoint, _Radius);

    float3 force = float3(0, 0, 0);

    for (int ox = -1; ox <= 1; ox++)
    for (int oy = -1; oy <= 1; oy++)
    for (int oz = -1; oz <= 1; oz++)
    {
        uint key = GetKeyFromHash(HashCell(centre.x + ox, centre.y + oy, centre.z + oz));
        uint start = _StartIndices[key];
        uint end = (key + 1 < _SpatialLookupLength) ? _StartIndices[key + 1] : _NumPoints;

        for (uint i = start; i < end; i++)
        {
            uint neighborIdx = _SpatialLookup[i].pointIndex;
            float3 neighborPos = _Positions[neighborIdx];

            float d2 = distance(neighborPos, samplePoint);
            if (d2 < sqrRadius)
            {
                // 範例行為：累積方向向量 (idk why chatGPT do this)
                force += normalize(neighborPos - samplePoint);
            }
        }
    }
    _Result[id.x] = force;
}